#include <string.h>
#include <stdint.h>
#include <assert.h>
#include <stdlib.h>
#include <time.h>
#include <math.h>

#include "inode.h"
#include "blocks.h"

int calculate_extra_datablocks(int total_size);

const int DATABLOCK_COUNT = 255 * 4096 / (sizeof(inode_t) + 4096); 
const int INODE_COUNT = 255 - DATABLOCK_COUNT;

void print_inode(inode_t *node){
    if(node){
        printf("node{refs: %d, mode: $04o, size: %d, block_0: %d, block_1: %d, rd: %d}\n", 
                node->refs, node->mode, node->size, node->block_0, node->block_1,node->rd_block);
    }
    else {
        printf("NULL\n");
    }
}

inode_t *get_inode(int inum){
    assert(inum < DATABLOCK_COUNT);
    int amountPerBlock = BLOCK_SIZE / sizeof(inode_t);
    int index = inum / amountPerBlock;
    int currentInode = inum % amountPerBlock;
    void *inode_block = blocks_get_inode_block(index);
    void *inode = inode_block + currentInode * sizeof(inode_t);
    return (inode_t *) inode;
}

int init_inode() {
  void *bbm = get_inodes_bitmap();
  for (int ii = 1; ii < INODE_COUNT; ++ii) {
    if (!bitmap_get(bbm, ii)) {
      bitmap_put(bbm, ii, 1);
      printf("+ alloc_inode_block() -> %d\n", ii);
      return ii;
    }
  }

  return -1;
}

void free_inode(int bnum) {
  printf("+ free_inode_block(%d)\n", bnum);
  inode_t *node = get_inode(bnum);
  for (int i = 0; i < INODE_COUNT; i++) {
    inode_t* current_node = get_inode(i);
    if (current_node->file_id == node->file_id) {
      current_node->refs -= 1;
    }
  }
  void *bbm = get_inode_blocks_bitmap();
  bitmap_put(bbm, bnum, 0);
}

int grow_inode(inode_t *node, int size) {
  int current_size = node->size;
  int total_size = current_size + size;

  if (total_size > BLOCK_SIZE && node->block_1 == -1) {
    int free_data_block = alloc_data_block();
    node->block_1 = free_data_block;
  }
  if (total_size > 2 * BLOCK_SIZE && node->rd_block == -1){
    int indirect_data_block = alloc_data_block();
    node->rd_block = free_data_block;
    int *block_array = blocks_get_block(indirect_data_block);
    int num_datablocks = calculate_extra_datablocks(total_size);
    if (num_datablocks > 255) {
      perror("Not enough memory. Please reduce the size of the file.\n");
      return -1;
    }
    for (int i = 0; i < num_datablocks; i++) {
      int free_data_block = alloc_data_block();
      block_array[i] = free_data_block;
    }
  }

  node->size = total_size;
  return 0;
}

int shrink_inode(inode_t *node, int size){
  int current_size = node->size;
  int total_size = current_size - size;
  if (node->block_0 == -1 || total_size < 0) {
    perror("Cannot reduce the size of the file.\n");
    return -1;
  }
  if (current_size > 2 * BLOCK_SIZE && node->rd_block != -1){
    int num_datablocks = calculate_extra_datablocks(current_size);
    int reduced_datablocks = calculate_extra_datablocks(current_size - size);
    int *block_array = blocks_get_block(node->rd_block);
    for (int i = num_datablocks - 1; i >= reduced_datablocks; i--) {
      free_data_block(block_array[i]);
      block_array[i] = 0;
    }
    if (reduced_datablocks == 0) {
      free_data_block(node->rd_block);
      node->rd_block = -1;
    }
  }

  if (current_size > BLOCK_SIZE && node->block_1 != -1 && total_size <= BLOCK_SIZE) {
    free_data_block(node->block_1);
    node->block_1 = -1;
  }

  node->size = total_size;
}

int calculate_extra_datablocks(int total_size) {
  int remainder = total_size - 2 * BLOCK_SIZE;

  if (remainder <= 0) {
    return 0;
  }

  int num_datablocks = remainder / BLOCK_SIZE + 1;
  if (remainder % BLOCK_SIZE == 0) {
    num_datablocks = remainder / BLOCK_SIZE;
  }
  return num_datablocks;
}

// based on cs3650 starter code

#define _GNU_SOURCE
#include <string.h>

#include <assert.h>
#include <errno.h>
#include <fcntl.h>
#include <stdint.h>
#include <stdio.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>

#include "bitmap.h"
#include "blocks.h"
#include "inode.h"

const int BLOCK_COUNT = 256; // we split the "disk" into 256 blocks
const int BLOCK_SIZE = 4096; // = 4K
const int NUFS_SIZE = BLOCK_SIZE * BLOCK_COUNT; // = 1MB

const int DATABLOCK_COUNT = 255 * 4096 / (sizeof(inode_t) + 4096); 
const int INODE_COUNT = 255 - DATABLOCK_COUNT;

const int DATABLOCK_BITMAP_SIZE = DATABLOCK_COUNT / 8;
const int INODE_BITMAP_SIZE = INODE_COUNT / 8;

const int BLOCK_BITMAP_SIZE = BLOCK_COUNT / 8;
// Note: assumes block count is divisible by 8

static int blocks_fd = -1;
static void *blocks_base = 0;

// Get the number of blocks needed to store the given number of bytes.
int bytes_to_blocks(int bytes) {
  int quo = bytes / BLOCK_SIZE;
  int rem = bytes % BLOCK_SIZE;
  if (rem == 0) {
    return quo;
  } else {
    return quo + 1;
  }
}

// Load and initialize the given disk image.
void blocks_init(const char *image_path) {
  blocks_fd = open(image_path, O_CREAT | O_RDWR, 0644);
  assert(blocks_fd != -1);

  // make sure the disk image is exactly 1MB
  int rv = ftruncate(blocks_fd, NUFS_SIZE);
  assert(rv == 0);

  // map the image to memory
  blocks_base =
      mmap(0, NUFS_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, blocks_fd, 0);
  assert(blocks_base != MAP_FAILED);
}

// Close the disk image.
void blocks_free() {
  int rv = munmap(blocks_base, NUFS_SIZE);
  assert(rv == 0);
}

// Get data block (add 5 for offset)
void *blocks_get_data_block(int bnum) {
  return blocks_base + BLOCK_SIZE * (bnum + INODE_COUNT + 1);
}

// Get inode block (add 1 for offset)
void *blocks_get_inode_block(int bnum) {
  return blocks_base + BLOCK_SIZE * (bnum + 1);
}

// Get the given block, returning a pointer to its start.
void *blocks_get_block(int bnum) { return blocks_base + BLOCK_SIZE * bnum; }

// Return a pointer to the beginning of the block bitmap.
// The size is BLOCK_BITMAP_SIZE bytes.
void *get_data_blocks_bitmap() { return blocks_get_block(0); }

// Return a pointer to the beginning of the inode table bitmap.
void *get_inode_blocks_bitmap() {
  uint8_t *block = blocks_get_block(0);

  // The inode bitmap is stored immediately after the block bitmap
  return (void *) (block + DATABLOCK_BITMAP_SIZE);
}

// Allocate a new block and return its index.
int alloc_data_block() {
  void *bbm = get_data_blocks_bitmap();

  for (int ii = INODE_COUNT + 1; ii < DATABLOCK_COUNT; ++ii) {
    if (!bitmap_get(bbm, ii)) {
      bitmap_put(bbm, ii, 1);
      printf("+ alloc_data_block() -> %d\n", ii);
      return ii;
    }
  }

  return -1;
}


// Deallocate the data block with the given index.
void free_data_block(int bnum) {
  printf("+ free_block(%d)\n", bnum);
  void *bbm = get_data_blocks_bitmap();
  bitmap_put(bbm, bnum, 0);
}

// Inode manipulation routines.
//
// Feel free to use as inspiration.

// based on cs3650 starter code

#ifndef INODE_H
#define INODE_H

#include "blocks.h"

typedef struct inode {
  int refs;  // reference count
  int file_id; // id of the file
  int mode;  // permission & type
  int size;  // bytes
  int block_0; // single block pointer (if max file size <= 4K)
  int block_1; // single block pointer (second one)
  int rd_block; // pointer to data block storing more pointers, only 1 redirect
} inode_t;

void print_inode(inode_t *node);

inode_t *get_inode(int inum);

int alloc_inode();

void free_inode();

int grow_inode(inode_t *node, int size);

int shrink_inode(inode_t *node, int size);

// int inode_get_pnum(inode_t *node, int fpn);

#endif


int item_inode = directory_lookup(dd, name);
assert(item_inode > 0);

inode_t *inode = get_inode(item_inode);
if (inode->mode == 0) {
    free_inode(item_inode);
}
else {
    dirent_t *base_directory = blocks_get_block(inode->block_0);
    int num_dirs = dd->size / sizeof(dirent_t);
    int num_dirs_per_block = BLOCK_SIZE / num_dirs;
    for (int i = 1; i < num_dirs_per_block && i < num_dirs; i++) {
        dirent_t* current_dir = base_directory + i;
        free_inode(current_dir->inum);
    }

    num_dirs -= num_dirs_per_block;
    
    base_directory = blocks_get_block(dd->block_1);
    for (int i = 0; i < num_dirs_per_block && i < num_dirs; i++) {
        dirent_t* current_dir = base_directory + i;
        free_inode(current_dir->inum);
    }

    num_dirs -= num_dirs_per_block;

    int counter = 0;
    int* datablocks = blocks_get_block(dd->rd_block);
    int amount_db = needed_datablocks(dd->size, 2 * BLOCK_SIZE);
    for (int i = 0; i < amount_db; i++) {
        base_directory = blocks_get_block(datablocks[i]);
        for (int j = 0; j < num_dirs_per_block && j < num_dirs; j++) {
            dirent_t* current_dir = base_directory + i;
            free_inode(current_dir->inum);
        }
        num_dirs -= num_dirs_per_block;
    }

    free_inode(item_inode);
}

    for (int i = 0; i < num_dirs; i++) {
        dirent_t* current_dir_block = dir_blocks[i];
        for (int j = 0; j < num_entries && j < total_entries; j++) {
            dirent_t current_dir = current_dir_block[j];
            if(current_dir.inum == -1) {
                strcpy(current_dir.name, name);
                current_dir.inum = inum;
                return 0;
            }
        }
        total_entries -= num_entries;
    }
